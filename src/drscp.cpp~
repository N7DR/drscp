// $Id$

// Released under the GNU Public License, version 2
//   see: https://www.gnu.org/licenses/gpl-2.0.html

// Principal author: N7DR

// Copyright owners:
//    N7DR

/*! \file   drscp.cpp

    Program to generate custom SCP (super check partial) files
    
    Much of this is based on the contest-statistics program, although the philosophy is
    quite different, and in this program we don't care whether a QSO counts for points, we 
    just want to try to determine a set of legitimate active calls, regardless of whether
    other aspects of a logged QSO might be incorrect.
*/

#include "command_line.h"
#include "diskfile.h"
#include "drscp.h"
#include "macros.h"
#include "string_functions.h"

#include <iostream>

using namespace std;

constexpr int CUTOFF_LIMIT   { 1 };     // will remove calls that appear this many (or fewer) times
constexpr int CLOCK_SKEW     { 2 };     // maximum permitted clock skew when comparing logs, in minutes
constexpr int FREQ_SKEW      { 2 };     // maximum permitted frequency skew when comparing logs, in kHz
constexpr int RUN_TIME_RANGE { 5 };     // half-width of time range for looking for a run, in minutes

using CALL_SET = set<string, decltype(&compare_calls)>;    // set in callsign order

constinit bool verbose { false };

int main(int argc, char** argv)
{ const command_line cl(argc, argv);

  if (cl.parameter_present("-v"))
    verbose = true;
  
  if (!cl.value_present("-dir"s))
    exit(0);
    
  const string rawdirname { cl.value("-dir"s) };
  
  if (!directory_exists(rawdirname, LINKS::INCLUDE))
  { cerr << "ERROR: raw directory " << rawdirname << " does not exist" << endl;
    exit(-1);
  }

/* we need to keep a copy of ALL qsos
  and then a pruned copy, the idea of which is that the rcalls
  need to be tested
*/

  unordered_set<string>                                scp_calls;               // the calls in the SCP list
  unordered_map<string /* tcall */, vector<small_qso>> all_qsos;                // all QSOs as recorded in the logs
  unordered_map<string /* tcall */, vector<small_qso>> pruned_qsos;             // some QSOs removed, removing more as we go along
  int                                                  n_valid_logs    { 0 };
  
  for (const string& logfile_name : files_in_directory(rawdirname, LINKS::INCLUDE))
  { vector<small_qso> qsos;

    for (const string& line : to_lines(to_upper(read_file(logfile_name))))
    { if (line.starts_with("QSO:"))
        qsos += small_qso { squash(line) };
    }

    if (!qsos.empty())
    { n_valid_logs++;
    
//      const string& first_tcall { qsos[0].tcall() };
      
      all_qsos += { qsos[0].tcall(), qsos };

// put all the tcalls into scp_calls. In theory, we need look only at the first line of each log,
// but we should check every line, in case the reflects a change of call partway through the contest
      FOR_ALL(qsos, [&scp_calls] (const small_qso& qso) { scp_calls += qso.tcall(); });
    }
  }
  
  if (verbose)
    cout << "total number of logs with valid QSOs = " << n_valid_logs << endl;

  if (all_qsos.empty())
  { cerr << "ERROR: no valid received logs" << endl;
    exit(-1);
  }

  if (verbose)
    cout << "Number of tcalls = " << scp_calls.size() << endl;

// ensure that all logs are in chronological order
  for (auto& [tcall, qsos] : all_qsos)
    SORT(qsos);

// convert all times to to relative minutes, just for human consumption
  int min_minutes { numeric_limits<int>::max() };

// get the global minimum time
  for (auto& [tcall, qsos] : all_qsos)
    min_minutes = min(min_minutes, qsos[0].time());

  for (auto& [tcall, qsos] : all_qsos)
    FOR_ALL(qsos, [min_minutes] (small_qso& qso) { qso.time(qso.time() - min_minutes); } );

// start with the pruned QSOs being identical to all_qsos
  pruned_qsos = all_qsos;

// prune all the QSOs for which the rcall is is a known tcall (regardless of whether anything else matches) 
  for ( auto& [ tcall, qsos ] : pruned_qsos )
    erase_if(qsos, [scp_calls] (const small_qso& qso) { return scp_calls.contains(qso.rcall()); } );

  if (verbose)
    cout << "nlogs = " << all_qsos.size() << endl;
  
// remove any logs for which all the rcalls are already in scp_calls
  erase_if(pruned_qsos, [] (const auto& pr) { return pr.second.empty(); } );

  if (verbose)
    cout << "pruned nlogs after removing rcalls in scp_calls = " << pruned_qsos.size() << endl;

// at some point we shall need a container of calls that do not have frequency info in the log
  unordered_set<string> calls_with_no_freq_info;
  
  for (const auto& [ tcall, qsos ] : all_qsos)
  { static const set<int> default_band_freq { 1800, 3500, 7000, 14000, 21000, 28000 };
  
    if (ALL_OF(qsos, [] (const small_qso& qso) { return default_band_freq.contains(qso.qrg()); }))
      calls_with_no_freq_info += tcall; 
  }

  if (verbose)
    cout << "Number of logs with no frequency info = " << calls_with_no_freq_info.size() << endl;

// remove QSOs for which the rcall appears to be a bust of another station's tcall

// get minilogs for each band and call
  const unordered_map<HF_BAND, decltype(all_qsos)> all_per_band_qsos    { build_minilog(all_qsos) };
  const unordered_map<HF_BAND, decltype(all_qsos)> pruned_per_band_qsos { build_minilog(pruned_qsos) };

// 160m
  HF_BAND band { HF_BAND::B160 };
//  HF_BAND band { HF_BAND::B80 };
//  HF_BAND band { HF_BAND::B40 };
//  HF_BAND band { HF_BAND::B20 };
//  HF_BAND band { HF_BAND::B15 };
//  HF_BAND band { HF_BAND::B10 };
  
  const unordered_map<string /* tcall */, vector<small_qso>>& all_qsos_this_band    { all_per_band_qsos.at(band) };
  const unordered_map<string /* tcall */, vector<small_qso>>& pruned_qsos_this_band { pruned_per_band_qsos.at(band) };
  
// put all the qsos on this band, and all the pruned qsos, into containers
  vector<small_qso> pruned_vec { build_vec(pruned_qsos_this_band) };

  const vector<small_qso> all_vec { build_vec(all_qsos_this_band) };

/*  \brief  Are two frequencies approximately the same?
    \param  qso1    QSO #1
    \param  qso2    QSO #2
    \param  def     whether calls with no detailed frequency info suggests a frequency match
    \return         whether <i>qso1</i> and <qso2> are reoughly on the same frequency (to within FREQ_SKEW kHz)
*/
  auto frequency_match = [&calls_with_no_freq_info] (const small_qso& qso1, const small_qso& qso2, const bool def) 
    { if (def)
        return ( (calls_with_no_freq_info.contains(qso1.tcall()) or calls_with_no_freq_info.contains(qso2.tcall())) or (abs(qso1.qrg() - qso2.qrg()) <= FREQ_SKEW) );
      else
        return ( (!calls_with_no_freq_info.contains(qso1.tcall()) and !calls_with_no_freq_info.contains(qso2.tcall())) and (abs(qso1.qrg() - qso2.qrg()) <= FREQ_SKEW) ); 
    };

// look for specific QSO busts, where the frequency and time in two logs match,
// and an rcall is a bust of a tcall
  unordered_set<int> ids_to_remove;
  
  const int minimum_minutes { pruned_vec[0].time() };
  const int maximum_minutes { pruned_vec[pruned_vec.size() - 1].time() };

// go through the pruned log, minute by minute; start by building maps from times to vector elements
  const unordered_map<int /* time */, vector<small_qso>::const_iterator> pruned_time_map { build_time_map(pruned_vec) };
  const unordered_map<int /* time */, vector<small_qso>::const_iterator> all_time_map    { build_time_map(all_vec) };
  
  for (int target_minutes { minimum_minutes }; target_minutes <= maximum_minutes; ++target_minutes)
  { const int lower_target_minutes { max(target_minutes - CLOCK_SKEW, minimum_minutes) };
    const int upper_target_minutes { min(target_minutes + CLOCK_SKEW, maximum_minutes) };

// create vector of (pruned) rcalls that are targets for this minute
    vector<small_qso> pruned_rcall_targets;
  
    const auto pruned_rcall_lb { lower_bound(pruned_time_map.at(lower_target_minutes), pruned_vec.cend(), lower_target_minutes, [] (const auto& element, const auto& target) { return (element.time() < target); }) };
    const auto pruned_rcall_ub { upper_bound(pruned_rcall_lb, pruned_vec.cend(), upper_target_minutes, [] (const auto& target, const auto& element) { return (target < element.time()); }) };
 
    copy(pruned_rcall_lb, pruned_rcall_ub, back_inserter(pruned_rcall_targets));     // these are all the pruned rcalls in this minute
 
// create vector of (all) tcalls that are targets for this minute
    vector<small_qso> all_tcall_targets;
  
    const auto all_tcall_lb { lower_bound(all_time_map.at(lower_target_minutes), all_vec.cend(), target_minutes, [] (const auto& element, const auto& target) { return (element.time() < target); }) };
    const auto all_tcall_ub { upper_bound(all_tcall_lb, all_vec.cend(), target_minutes, [] (const auto& target, const auto& element) { return (target < element.time()); }) }; 
  
    copy(all_tcall_lb, all_tcall_ub, back_inserter(all_tcall_targets));

// look for matches
    for (const small_qso& rqso : pruned_rcall_targets)
    { const auto it { find_if(all_tcall_targets.cbegin(), all_tcall_targets.cend(),
                               [&frequency_match, &rqso] (const small_qso& tqso) 
                                 { //const bool rv_f   { frequency_match(tqso, rqso, true) };
                                   //const bool bust_1 { is_bust(tqso.tcall(), rqso.rcall()) and (tqso.rcall() == rqso.tcall()) };      // did the rcall bust the tcall?
                                   //const bool bust_2 { is_bust(rqso.tcall(), tqso.rcall()) and is_bust(tqso.tcall(), rqso.rcall()) }; // the tcall might have ALSO bust the rcall
                                   
                                   //return (rv_f and (bust_1 or bust_2));
                                   return (frequency_match(tqso, rqso, true) and
                                            ((is_bust(tqso.tcall(), rqso.rcall()) and (tqso.rcall() == rqso.tcall())) or 
                                              (is_bust(rqso.tcall(), tqso.rcall()) and (is_bust(tqso.tcall(), rqso.rcall()))))); })
                    };
  
      if (it != all_tcall_targets.end())
      { ids_to_remove += rqso.id();
        
        if (verbose)
          cout << "marked for removal: " << rqso << "; tcall match = " << *it << endl;
      }
    }  
  }
  
  if (verbose)
    cout << "number of QSO IDs to remove: " << ids_to_remove.size() << endl;
  
// remove the marked QSOs
  erase_if(pruned_vec, [&ids_to_remove] (const small_qso& qso) { return ids_to_remove.contains(qso.id()); });
  
  if (verbose)
    cout << "current number of QSOs in pruned_vec = " << pruned_vec.size() << endl;

/* now go through pruned_vec, and for each rcall look to see if it's a bust
   of a non-entrant (i.e., not a tcall) rcall that is running on that frequency
   
   This will be quite rare, as non-entrants typically do not run.
*/

  if (verbose)
    cout << "Now to look for non-entrant busts" << endl;

// build pseudo-logs of rcalls
  unordered_map<string /* rcall */, vector<small_qso> /* rcall log */> rcall_logs;
  set<string>                                                          rcalls;
    
  FOR_ALL(pruned_vec, [&rcalls, &rcall_logs] (const small_qso& qso) { rcall_logs[qso.rcall()] += qso; 
                                                                      rcalls += qso.rcall();
                                                                    });

  for (auto& [ rcall, rcall_log ] : rcall_logs)       // sort each rcall log chronologically; C++ does not permit lambdas with structured binding
    SORT(rcall_log);
  
  if (verbose)
    cout << "Number of rcall logs = " << rcall_logs.size() << endl;
 
// this can't be const as [rcall] might create an empty unordered_set later
  unordered_map<string /* call */, unordered_set<string> /* possible_busts */> possible_rcall_busts { possible_busts(rcalls) }; // all the bust permutations in <i>rcalls</i>

// count the number of times each remaining rcall appears
  map<string /* rcall */, int /* count */> histogram;

  FOR_ALL(pruned_vec, [&histogram] (const small_qso& qso) { histogram[qso.rcall()]++; });

// invert the histogram, in order of greatest count to lowest
  map<int /* number of QSOs */, set<string> /* rcalls */, greater<int>> inv_histogram;
  
  for (auto& [ rcall, count ] : histogram)  // structured binding not permitted in lambda
    inv_histogram[count] += rcall; 

  auto inv_histogram_it { inv_histogram.begin() };
  int  counter          { 0 };
  
  ids_to_remove.clear();
  
  while (inv_histogram_it != inv_histogram.end())
  { if (verbose)
      cout << counter << " count : " << inv_histogram_it->first << endl;

    set<string> rcalls_this_count = inv_histogram_it->second;
  
    if (verbose)
      cout << "number of rcalls = " << rcalls_this_count.size() << endl;
  
    for (const auto& rcall : rcalls_this_count)
    { if (verbose)
        cout << "rcall = " << rcall << endl;
  
      vector<small_qso> log_of_rcall_and_busts { rcall_logs[rcall] };   // start with the log of this rcall
  
      const unordered_set<string> rcall_busts { possible_rcall_busts[rcall] };  // all the busts of this rcall; no not use .at() here, as [rcall] will have no entry if there are no busts of rcall 
    
      FOR_ALL(rcall_busts, [&log_of_rcall_and_busts, &rcall_logs] (const string& rcall_bust) { log_of_rcall_and_busts += rcall_logs[rcall_bust]; } );
      SORT(log_of_rcall_and_busts);       // put the combined log for rcall and all its busts into chronological order
        
// look for busts during runs
      for (const auto& test_qso : log_of_rcall_and_busts)
      { if (test_qso.rcall() != rcall)                                      // if its a bust of the target rcall
        { if (verbose)
            cout << "QSO with possible bust rcall = " << test_qso << " (bust of " << rcall << ")" << endl;
 
// find ALL the QSOs within the range for which the rcall matches this rcall. So that implies all, not pruned
     
// go back and forward five minutes
          const int target_minutes   { test_qso.time() };
          const small_qso target_qso { test_qso };

// ±5 minutes; ± 2kHz        
          const int lower_target_minutes { max(target_minutes - RUN_TIME_RANGE, minimum_minutes) };
          const int upper_target_minutes { min(target_minutes + RUN_TIME_RANGE, maximum_minutes) };
       
          const auto lb { lower_bound(all_time_map.at(lower_target_minutes), all_vec.cend(), lower_target_minutes, [] (const auto& element, const auto& target) { return (element.time() < target); }) };
          const auto ub { upper_bound(lb, all_vec.cend(), upper_target_minutes, [] (const auto& target, const auto& element) { return (target < element.time()); }) }; 
          
          const int low_time  { lb->time() };
          const int high_time { prev(ub)->time() };
        
          if (verbose)
            cout << "time range: " << low_time << " to " << high_time
               << " for target time = " << target_minutes << "; lower target = " << lower_target_minutes << ", upper target = " << upper_target_minutes << endl;
          
          if ((high_time - low_time) > 11)
          { cerr << "excessive time range" << endl;
            exit(-1);
          }
        
          unordered_set<int> qrgs_of_rcall;       // all the QRGs at which rcall was found to be QRV during the time window
        
          for (auto it { lb }; it != ub; ++it)
          { if (it->rcall() == rcall)
              qrgs_of_rcall += it->qrg();
          }

          bool approx_same_qrg = ANY_OF(lb, ub, [&calls_with_no_freq_info, &frequency_match, &target_qso, &rcall] (const small_qso& qso)
                                         { if (qso.rcall() != rcall) // select only ones with real correct call
                                             return false;
                                                                            
                                           if (verbose and frequency_match(qso, target_qso, false))
                                           { cout << "MATCH: " << qso << " | " << target_qso << endl;
                                             cout << "  freq info1: " << calls_with_no_freq_info.contains(qso.tcall())  << endl;
                                             cout << "  freq info2: " << calls_with_no_freq_info.contains(target_qso.tcall())  << endl;
                                             cout << "  comparison: " << (abs(qso.qrg() - target_qso.qrg()) <= 2) << endl;
                                           }
                                                                            
                                           return frequency_match(qso, target_qso, false);        // use frequency_match lambda
                                         } );
                                                                        
           if (verbose)
             cout << (approx_same_qrg ? "matching QRG for possible run" : "not a run") << endl;
           
           if (approx_same_qrg)
           { ids_to_remove += test_qso.id();
             
             if (verbose)
               cout << "will remove QSO: " << test_qso << endl;
           }
        }                                                              
      }
    }
    
    inv_histogram_it++;
    counter++;
  }
  
// remove the QSOs marked for removal
  erase_if(pruned_vec, [&ids_to_remove] (const small_qso& qso) { return ids_to_remove.contains(qso.id()); });

  if (verbose)
    cout << "Number of remaining calls after processing busts = " << pruned_vec.size() << endl;

// regenerate the histogram and remove the calls with too few occurrences
  histogram.clear();

  for (const small_qso& qso : pruned_vec)
    histogram[qso.rcall()]++;

// remove all the rcalls that are at ore below CUTOFF_LIMIT (default = 1)
  if (verbose)
    cout << "Erasing calls beow CUTOFF_LIMIT ( =" << CUTOFF_LIMIT << " )" << endl;
  
   for (auto& [ rcall, count ] : histogram)
   { if (count <= CUTOFF_LIMIT)
     { if (verbose)
         cout << "Erasing call: " << rcall << endl;
       erase_if(pruned_vec, [rcall] (const small_qso& qso) { return (qso.rcall() == rcall); });
     }
   }
   
  if (verbose)
    cout << "final number of QSOs in pruned_vec = " << pruned_vec.size() << endl;

// add the remaining rcalls to scp_calls
  FOR_ALL(pruned_vec, [&scp_calls] (const small_qso& qso) { scp_calls += qso.rcall(); } );   // will try to add many times; perhaps should make a unique list of rcalls first

  if (verbose)
    cout << "final number of SCP calls = " << scp_calls.size() << endl;

  CALL_SET output_calls(compare_calls);      // the set to be output
 
  FOR_ALL(scp_calls,    [&output_calls] (const string& call) { output_calls += call; } );
  FOR_ALL(output_calls, []              (const string& call) { cout << call << endl; } );

  if (verbose)
    cout << "total number of SCP calls = " << output_calls.size() << endl;
  
  return 1;
}

/*  \brief          Is a copied call a bust of another call?
    \param  call    target (correct) call
    \param  copied  copied call
    \return         whether <i>copied</i> is a plausiblg bust of <i>call</i>
    
    This is shamelessly pulled from contest_statistics, with no substantive changes
*/
bool is_bust(const string& call, const string& copied) noexcept
{ if (call == copied)
    return false;                // not a bust if it's copied OK

  if ( abs(static_cast<int>(call.length()) - static_cast<int>(copied.length())) >= 2 )
    return false;                // not a bust if the lengths differ by 2 or more

  if ( abs(static_cast<int>(call.length()) - static_cast<int>(copied.length())) == 1 )  // lengths differ by unity
  { const string& longer  { (call.length() > copied.length() ? call : copied) };
    const string& shorter { (call.length() > copied.length() ? copied : call) };

    if (contains(longer, shorter))
      return true;

// is the bust in the form of an additional character somewhere in the call?
    for (size_t posn { 1 }; posn < longer.length() - 1; ++posn)
    { const string tmp { longer.substr(0, posn) + longer.substr(posn + 1) };

      if (tmp == shorter)
        return true;
    }

    return false;
  }

// call and copied are the same length; do they differ by exactly one character?
  int differences { 0 };

  for (size_t posn { 0 }; posn < call.length(); ++posn)
  { if (call[posn] != copied[posn])
      differences++;
  }

  if (differences == 1)
    return true;

// is there a character inversion?
  for (size_t posn { 0 }; posn < call.length() - 1; ++posn)
  { string call_tmp { call };

    swap(call_tmp[posn], call_tmp[posn + 1]);

    if (call_tmp == copied)
      return true;
  }

  return false;
}

/*  \brief                  Split a log into per-band minilogs
    \param  qsos_per_call   all the QSOs for each call
    \return                 <i>qsos_per_call</i> divided into per-band logs
*/
auto build_minilog(const unordered_map<string /* tcall */, vector<small_qso>>& qsos_per_call) -> unordered_map<HF_BAND, base_type<decltype(qsos_per_call)>> 
{ unordered_map<HF_BAND, base_type<decltype(qsos_per_call)>> rv;
  
  for (const auto& [ tcall, qsos ] : qsos_per_call)
  { for (const small_qso& qso : qsos)
    { const HF_BAND band_this_qsos { qso.band() };
      const string& tcall          { qso.tcall() };
      
      rv[band_this_qsos][tcall] += qso;
    }
  }
  
  return rv;
}

/*  \brief                  Convert a minilog into a time-ordered vector
    \param  qsos_per_call   all the QSOs for each call
    \return                 <i>qsos_per_call</i> organised as a single chronological vector
*/
vector<small_qso> build_vec(const unordered_map<string /* tcall */, vector<small_qso>>& qsos_per_call)
{ vector<small_qso> rv;            // all QSOs on this band
  
// calculate the putative size
  size_t rv_size { 0 };
  
  for (const auto& [ tcall, qsos_this_call ] : qsos_per_call)  
    rv_size += qsos_this_call.size();
    
  rv.reserve(rv_size);
    
  for (const auto& [ tcall, qsos_this_call ] : qsos_per_call)
    FOR_ALL(qsos_this_call, [&rv] (const small_qso& qso) { rv += qso; } );

//  cout << "number of " << HF_BAND_STR.at(static_cast<int>(band)) << "m (half-)QSOs = " << vec.size() << endl;

// put in chronological order
  SORT(rv);
  
  return rv;
}

/*  \brief          Build a map that converts from time to the iterator for the first element for that minute in a chronologically-sorted QSO vector
    \param  vec     chronologically-sorted QSO vector
    \return         map that converts from time (for each minute) to the iterator for the first element of <i>vec</i>for that minute
*/
unordered_map<int /* time */, vector<small_qso>::const_iterator> build_time_map(const vector<small_qso>& vec)
{ unordered_map<int, vector<small_qso>::const_iterator> rv;

  int prior_time = -1;  // arbitrary number less than zero

  for (auto it = vec.cbegin(); it != vec.cend(); ++it)
  { if (it->time() != prior_time)
    { while (it->time() != (prior_time + 1))
      { prior_time++;
        
        rv += { prior_time, it };   // the current iterator should be used for missing times
      }
      
 //     if (it->time() != (prior_time + 1))
 //     { while (it->time() != (prior_time + 1))
 //       { prior_time++;
 //       
 //         rv += { prior_time, it/* rv.at(prior_time - 1) */};
//        }
//      }
      
      rv += { it->time(), it };
      prior_time = it->time();
    }
  }
  
  return rv;
}

#if 1
CALL_SET process_band(const unordered_map<string /* tcall */, vector<small_qso>>& pruned_qsos_this_band,
                      const unordered_map<string /* tcall */, vector<small_qso>>& all_qsos_this_band,
                      const unordered_set<string>& calls_with_no_freq_info,
                      const unordered_set<string>& scp_calls)
{
  // put all the qsos on this band, and all the pruned qsos, into containers
  vector<small_qso> pruned_vec { build_vec(pruned_qsos_this_band) };

  const vector<small_qso> all_vec { build_vec(all_qsos_this_band) };

/*  \brief  Are two frequencies approximately the same?
    \param  qso1    QSO #1
    \param  qso2    QSO #2
    \param  def     whether calls with no detailed frequency info suggests a frequency match
    \return         whether <i>qso1</i> and <qso2> are reoughly on the same frequency (to within FREQ_SKEW kHz)
*/
  auto frequency_match = [&calls_with_no_freq_info] (const small_qso& qso1, const small_qso& qso2, const bool def) 
    { if (def)
        return ( (calls_with_no_freq_info.contains(qso1.tcall()) or calls_with_no_freq_info.contains(qso2.tcall())) or (abs(qso1.qrg() - qso2.qrg()) <= FREQ_SKEW) );
      else
        return ( (!calls_with_no_freq_info.contains(qso1.tcall()) and !calls_with_no_freq_info.contains(qso2.tcall())) and (abs(qso1.qrg() - qso2.qrg()) <= FREQ_SKEW) ); 
    };

// look for specific QSO busts, where the frequency and time in two logs match,
// and an rcall is a bust of a tcall
  unordered_set<int> ids_to_remove;
  
  const int minimum_minutes { pruned_vec[0].time() };
  const int maximum_minutes { pruned_vec[pruned_vec.size() - 1].time() };

// go through the pruned log, minute by minute; start by building maps from times to vector elements
  const unordered_map<int /* time */, vector<small_qso>::const_iterator> pruned_time_map { build_time_map(pruned_vec) };
  const unordered_map<int /* time */, vector<small_qso>::const_iterator> all_time_map    { build_time_map(all_vec) };
  
  for (int target_minutes { minimum_minutes }; target_minutes <= maximum_minutes; ++target_minutes)
  { const int lower_target_minutes { max(target_minutes - CLOCK_SKEW, minimum_minutes) };
    const int upper_target_minutes { min(target_minutes + CLOCK_SKEW, maximum_minutes) };

// create vector of (pruned) rcalls that are targets for this minute
    vector<small_qso> pruned_rcall_targets;
  
    const auto pruned_rcall_lb { lower_bound(pruned_time_map.at(lower_target_minutes), pruned_vec.cend(), lower_target_minutes, [] (const auto& element, const auto& target) { return (element.time() < target); }) };
    const auto pruned_rcall_ub { upper_bound(pruned_rcall_lb, pruned_vec.cend(), upper_target_minutes, [] (const auto& target, const auto& element) { return (target < element.time()); }) };
 
    copy(pruned_rcall_lb, pruned_rcall_ub, back_inserter(pruned_rcall_targets));     // these are all the pruned rcalls in this minute
 
// create vector of (all) tcalls that are targets for this minute
    vector<small_qso> all_tcall_targets;
  
    const auto all_tcall_lb { lower_bound(all_time_map.at(lower_target_minutes), all_vec.cend(), target_minutes, [] (const auto& element, const auto& target) { return (element.time() < target); }) };
    const auto all_tcall_ub { upper_bound(all_tcall_lb, all_vec.cend(), target_minutes, [] (const auto& target, const auto& element) { return (target < element.time()); }) }; 
  
    copy(all_tcall_lb, all_tcall_ub, back_inserter(all_tcall_targets));

// look for matches
    for (const small_qso& rqso : pruned_rcall_targets)
    { const auto it { find_if(all_tcall_targets.cbegin(), all_tcall_targets.cend(),
                               [&frequency_match, &rqso] (const small_qso& tqso) 
                                 { //const bool rv_f   { frequency_match(tqso, rqso, true) };
                                   //const bool bust_1 { is_bust(tqso.tcall(), rqso.rcall()) and (tqso.rcall() == rqso.tcall()) };      // did the rcall bust the tcall?
                                   //const bool bust_2 { is_bust(rqso.tcall(), tqso.rcall()) and is_bust(tqso.tcall(), rqso.rcall()) }; // the tcall might have ALSO bust the rcall
                                   
                                   //return (rv_f and (bust_1 or bust_2));
                                   return (frequency_match(tqso, rqso, true) and
                                            ((is_bust(tqso.tcall(), rqso.rcall()) and (tqso.rcall() == rqso.tcall())) or 
                                              (is_bust(rqso.tcall(), tqso.rcall()) and (is_bust(tqso.tcall(), rqso.rcall()))))); })
                    };
  
      if (it != all_tcall_targets.end())
      { ids_to_remove += rqso.id();
        
        if (verbose)
          cout << "marked for removal: " << rqso << "; tcall match = " << *it << endl;
      }
    }  
  }
  
  if (verbose)
    cout << "number of QSO IDs to remove: " << ids_to_remove.size() << endl;
  
// remove the marked QSOs
  erase_if(pruned_vec, [&ids_to_remove] (const small_qso& qso) { return ids_to_remove.contains(qso.id()); });
  
  if (verbose)
    cout << "current number of QSOs in pruned_vec = " << pruned_vec.size() << endl;

/* now go through pruned_vec, and for each rcall look to see if it's a bust
   of a non-entrant (i.e., not a tcall) rcall that is running on that frequency
   
   This will be quite rare, as non-entrants typically do not run.
*/

  if (verbose)
    cout << "Now to look for non-entrant busts" << endl;

// build pseudo-logs of rcalls
  unordered_map<string /* rcall */, vector<small_qso> /* rcall log */> rcall_logs;
  set<string>                                                          rcalls;
    
  FOR_ALL(pruned_vec, [&rcalls, &rcall_logs] (const small_qso& qso) { rcall_logs[qso.rcall()] += qso; 
                                                                      rcalls += qso.rcall();
                                                                    });

  for (auto& [ rcall, rcall_log ] : rcall_logs)       // sort each rcall log chronologically; C++ does not permit lambdas with structured binding
    SORT(rcall_log);
  
  if (verbose)
    cout << "Number of rcall logs = " << rcall_logs.size() << endl;
 
// this can't be const as [rcall] might create an empty unordered_set later
  unordered_map<string /* call */, unordered_set<string> /* possible_busts */> possible_rcall_busts { possible_busts(rcalls) }; // all the bust permutations in <i>rcalls</i>

// count the number of times each remaining rcall appears
  map<string /* rcall */, int /* count */> histogram;

  FOR_ALL(pruned_vec, [&histogram] (const small_qso& qso) { histogram[qso.rcall()]++; });

// invert the histogram, in order of greatest count to lowest
  map<int /* number of QSOs */, set<string> /* rcalls */, greater<int>> inv_histogram;
  
  for (auto& [ rcall, count ] : histogram)  // structured binding not permitted in lambda
    inv_histogram[count] += rcall; 

  auto inv_histogram_it { inv_histogram.begin() };
  int  counter          { 0 };
  
  ids_to_remove.clear();
  
  while (inv_histogram_it != inv_histogram.end())
  { if (verbose)
      cout << counter << " count : " << inv_histogram_it->first << endl;

    set<string> rcalls_this_count = inv_histogram_it->second;
  
    if (verbose)
      cout << "number of rcalls = " << rcalls_this_count.size() << endl;
  
    for (const auto& rcall : rcalls_this_count)
    { if (verbose)
        cout << "rcall = " << rcall << endl;
  
      vector<small_qso> log_of_rcall_and_busts { rcall_logs[rcall] };   // start with the log of this rcall
  
      const unordered_set<string> rcall_busts { possible_rcall_busts[rcall] };  // all the busts of this rcall; no not use .at() here, as [rcall] will have no entry if there are no busts of rcall 
    
      FOR_ALL(rcall_busts, [&log_of_rcall_and_busts, &rcall_logs] (const string& rcall_bust) { log_of_rcall_and_busts += rcall_logs[rcall_bust]; } );
      SORT(log_of_rcall_and_busts);       // put the combined log for rcall and all its busts into chronological order
        
// look for busts during runs
      for (const auto& test_qso : log_of_rcall_and_busts)
      { if (test_qso.rcall() != rcall)                                      // if its a bust of the target rcall
        { if (verbose)
            cout << "QSO with possible bust rcall = " << test_qso << " (bust of " << rcall << ")" << endl;
 
// find ALL the QSOs within the range for which the rcall matches this rcall. So that implies all, not pruned
     
// go back and forward five minutes
          const int target_minutes   { test_qso.time() };
          const small_qso target_qso { test_qso };

// ±5 minutes; ± 2kHz        
          const int lower_target_minutes { max(target_minutes - RUN_TIME_RANGE, minimum_minutes) };
          const int upper_target_minutes { min(target_minutes + RUN_TIME_RANGE, maximum_minutes) };
       
          const auto lb { lower_bound(all_time_map.at(lower_target_minutes), all_vec.cend(), lower_target_minutes, [] (const auto& element, const auto& target) { return (element.time() < target); }) };
          const auto ub { upper_bound(lb, all_vec.cend(), upper_target_minutes, [] (const auto& target, const auto& element) { return (target < element.time()); }) }; 
          
          const int low_time  { lb->time() };
          const int high_time { prev(ub)->time() };
        
          if (verbose)
            cout << "time range: " << low_time << " to " << high_time
               << " for target time = " << target_minutes << "; lower target = " << lower_target_minutes << ", upper target = " << upper_target_minutes << endl;
          
          if ((high_time - low_time) > 11)
          { cerr << "excessive time range" << endl;
            exit(-1);
          }
        
          unordered_set<int> qrgs_of_rcall;       // all the QRGs at which rcall was found to be QRV during the time window
        
          for (auto it { lb }; it != ub; ++it)
          { if (it->rcall() == rcall)
              qrgs_of_rcall += it->qrg();
          }

          bool approx_same_qrg = ANY_OF(lb, ub, [&calls_with_no_freq_info, &frequency_match, &target_qso, &rcall] (const small_qso& qso)
                                         { if (qso.rcall() != rcall) // select only ones with real correct call
                                             return false;
                                                                            
                                           if (verbose and frequency_match(qso, target_qso, false))
                                           { cout << "MATCH: " << qso << " | " << target_qso << endl;
                                             cout << "  freq info1: " << calls_with_no_freq_info.contains(qso.tcall())  << endl;
                                             cout << "  freq info2: " << calls_with_no_freq_info.contains(target_qso.tcall())  << endl;
                                             cout << "  comparison: " << (abs(qso.qrg() - target_qso.qrg()) <= 2) << endl;
                                           }
                                                                            
                                           return frequency_match(qso, target_qso, false);        // use frequency_match lambda
                                         } );
                                                                        
           if (verbose)
             cout << (approx_same_qrg ? "matching QRG for possible run" : "not a run") << endl;
           
           if (approx_same_qrg)
           { ids_to_remove += test_qso.id();
             
             if (verbose)
               cout << "will remove QSO: " << test_qso << endl;
           }
        }                                                              
      }
    }
    
    inv_histogram_it++;
    counter++;
  }
  
// remove the QSOs marked for removal
  erase_if(pruned_vec, [&ids_to_remove] (const small_qso& qso) { return ids_to_remove.contains(qso.id()); });

  if (verbose)
    cout << "Number of remaining calls after processing busts = " << pruned_vec.size() << endl;

// regenerate the histogram and remove the calls with too few occurrences
  histogram.clear();

  for (const small_qso& qso : pruned_vec)
    histogram[qso.rcall()]++;

// remove all the rcalls that are at ore below CUTOFF_LIMIT (default = 1)
  if (verbose)
    cout << "Erasing calls beow CUTOFF_LIMIT ( =" << CUTOFF_LIMIT << " )" << endl;
  
   for (auto& [ rcall, count ] : histogram)
   { if (count <= CUTOFF_LIMIT)
     { if (verbose)
         cout << "Erasing call: " << rcall << endl;
       erase_if(pruned_vec, [rcall] (const small_qso& qso) { return (qso.rcall() == rcall); });
     }
   }
   
  if (verbose)
    cout << "final number of QSOs in pruned_vec = " << pruned_vec.size() << endl;

// add the remaining rcalls to scp_calls

  unordered_set<string> local_scp_calls { scp_calls };

  FOR_ALL(pruned_vec, [&local_scp_calls] (const small_qso& qso) { local_scp_calls += qso.rcall(); } );   // will try to add many times; perhaps should make a unique list of rcalls first

  if (verbose)
    cout << "final number of SCP calls = " << local_scp_calls.size() << endl;

  CALL_SET output_calls(compare_calls);      // the set to be output
 
  FOR_ALL(local_scp_calls, [&output_calls] (const string& call) { output_calls += call; } );
  FOR_ALL(output_calls,    []              (const string& call) { cout << call << endl; } );

  if (verbose)
    cout << "total number of SCP calls = " << output_calls.size() << endl;
  
  return output_calls;
}
#endif
